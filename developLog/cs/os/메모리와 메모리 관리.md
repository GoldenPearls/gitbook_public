# 메모리와 메모리 관리

## 1. 메모리

> CPU는 그저 메모리에 올라와 있는 프로그램의 **명령어들을 실행**

### 🍇 메모리 계층

![](https://velog.velcdn.com/images/prettylee620/post/38c47521-e9b1-43b0-8873-970ab27dfe17/image.png)

1. **레지스터** : CPU 안에 있는 작은 메모리
2. **캐시** : L1, L2 캐시를 지칭한다.
3. **주기억장치** : (= 메모리, RAM)
4. **저장장치(HDD SDD)** : (= 보조기억장치)

### 🍇 캐시

> 캐시는 데이터를 미리 복사해 놓는 `임시 저장소`이자 빠른 장치와 느린 장치에서 **속도 차이에 따른 병목 현상을 줄이기 위한 메모리**

* 프로그램이 수행될 때 나타나는 지역성을 이용하여 메모리나 디스크에서 사용되었던 내용을 특별히 빠르게 접근할 수 있는 곳에 보관하고 관리함으로써 이 내용을 다시 필요로할 때 보다 빠르게 참조하도록 하는 것
* 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 레지스터 계층을 둬서 속도 차이 해결 - **캐시 계층**

#### **Locality(지역성, 구역성)**

> Q. 그렇다면 캐시계층을 두는 것이 아니라 **캐시를 직접 설정**해야 할 때는 어떻게…?

A. 자주 사용하는 **데이터를 기반으로 설정**해야 하는데 그것이 **근거**가 되는 것이 바로 **지역성**

* 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
* 스래싱(Thrashing)을 방지하기 위한 워킹 셋 이론의 기반
* 데닝(Denning) 교수에 의해 구역성의 개념이 증명됐으며, 캐시 메모리 시스템의 이론적 근거

| 종류                         | 설명                                                                                                                                                                                                                               |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 시간적 지역성(Temporal Locality) | <p>▶ 최근 사용한 데이터를 다시 접근하려는 특성 for 문 반복문의 i와 같은 느낌<br>▶ 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음 반복, 스택, 부프로그램과 관련<br>▶ 최근 사용되었던 기억장소들이 집중적으로<br>액세스# Loop(루프), Stack(스택), Subroutine(서브루틴),Counting(카운팅), Totaling(집계)<br>#루스서카집</p> |
| 공간적 지역성(SpatialLocality)   | <p>▶ 어느 하나의 페이지를 참조하면 가상공간상 그 근처의 페이지를 계속 참조할 가능성이 높음<br>▶ 프로그램 실행시 일정 위치의 페이지를 집중적으로 액세스하는 현상<br># Array(배열) : 각 요소들에 i가 할당되며 해당 배열 연속적 접근, Sequential Code(순차적 코드) ★</p>                                                       |

#### 캐시히트와 캐시미스

1. **캐시 히트(Cache Hit)**

* CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있을 경우
* 캐시에서 원하는 데이터를 찾음 ⇒ 데이터를 해당 `제어장치`를 거쳐 가져옴(빠름)

2. **캐시 미스(Cache Miss)**

* 해당 데이터가 캐시에 없다면 주 메모리에 가서 데이터를 찾아옴(느림)

> 🔗 출처 : 면접을 위한 cs 지식

![](https://velog.velcdn.com/images/prettylee620/post/2b61585e-d0cc-46e0-a46c-f794769bfa11/image.png)

#### 캐시매핑

* **캐시가 히트되기 위해 매핑하는 방법**을 말하며 CPU의 레지스터와 주 메모리(RAM) 간 데이터를 주고받을 때 기반으로 설명
* 레지스터는 주 메모리에 비해 괴장히 작고 주 메모리는 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 잘 해주려면 매핑이 중요

> `Mapping`이란 가상주소와 물리주소**의 대응 관계 또는 가상 주소로부터 물리 주소를 찾아내는 일**을 말한다.

* 직접 매핑, 연관 매핑, 집합 연관 매핑

#### 웹 브라우저의 캐시

> 사용자의 커스텀 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청 시 자신을 나타내는 **아이덴티티나 중복 요청 방지를 위해 사용**

1. **쿠키**

* 만료기간이 `있는` 키-값 저장소
* same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송되며, 4KB까지 데이터를 저장할 수 있고 만료기간을 정할 수 있다.

2. **로컬 스토리지**

* 만료기간이 `없는` 키-값 저장소
* 10MB까지 저장할 수 있으며, 웹 브라우저를 닫아도 유지되고 도메인 단위로 저장, 생성

3. 세션 스토리지

* 만료 기한이 없는 키-값 저장소
* 탭 단위로 세션 스토리지 생성하며, 탭을 닫을 때 해당 데이터 삭제

#### 데이터베이스의 캐싱 계층

* 데이터 베이스 시스템 구축 시에도 메인 데이터베이스 위에 **레디스(REDIS) 데이터베이스 계층**을 `캐싱 계층`으로 둬서 성능 향상

![](https://velog.velcdn.com/images/prettylee620/post/65b6707e-0bb7-4465-b3f6-59b6619031a8/image.png)

## 2. **기억장치 관리**

### 🍇 **메모리 관리 기법**

> 운영체제의 대표적인 할 일 중 하나인 메모리 관리는 컴퓨터 내의 한정된 메모리를 극한으로 활용해야 함

* 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

### 🍇 **기억장치의 관리 전략의 개요**

* 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기(When), 적재 위치(Where) 등을 지정하여 **한정된 주기억장치의 공간을 효율적**으로 사용하기 위함
* \#**반**입(Fetch), **배**치(Placement), **할**당(Allocation), **교**체(Replacemnet) **반배할교**

### 🍇 가상 메모리

> `가상 메모리`는 메모리 관리 기법의 하나로 컴퓨터가 **실제로 이용 가능한 메모리 자원을 추상화**하여 이를 사용하는 사용자들에게는 큰 메모리로 보이게 만드는 방법

* 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법
* 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
* 주기억장치의 이용률과 다중 프로그래밍 효율을 높일 수 있음
* 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업 필요
* 블록 단위로 나누어 사용하므로 연속 할당 방식의 단편화 해결 가능

#### 스와핑\*\*(프로세스 교체)\*\*

1. 만약 가상 메모리에는 존재하지만 **실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우** `페이지 볼트`가 발생
2. 스와핑 : 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 관리하는 것
3. 프로그램 전체를 주기억장치에 할당하여 사용하다 필요없는 프로그램은 다른 프로그램이랑 교체된다 .
4. 프로세서 할당이 끝나고 수행 완료된 프로세스는 **보조기억장치로 보내고(스왑 아웃)**
5. **새**롭게 시작하는 프로세스는 **주기억장치(메모리)에 적재(스왑 인)**
6. 스왑아웃,스왑인 ->주기억장치기준
7. 프로세스는 메모리에 있어야 수행되므로 일시적으로 디스크로 이동했다가 메모리로 되돌아와 다시 수행 가능

![](https://velog.velcdn.com/images/prettylee620/post/1ba21766-9173-4bc2-9780-53eb8eeef8ec/image.png)

#### 페이지 폴트

**페이지 부재** 또는 **페이지 폴트**는 메모리에 적재된 페이지중에 사용 페이지가 없을 때를 가리킨다. 시스템의 종류에 따라 약간 다를 수 있으나, 대체로는 빈 페이지가 하나도 없거나, 미리 정한 수보다 적을 때 발생한다.

### 🍇 **반입(Fetch) 전략 : 메모리 적재 시기 결정**

> 보조기억장치에 보관중인 프로그램이나 데이터를 언제(When) 주기억장치로 적재할 것인지를 결정하는 전략

▶ 요구 반입(Demand Fetch): 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법

▶ 예상 반입(Anticipatory Fetch): 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법

### 🍇 **배치(Placement) 전략 : 메모리 적재 위치 결정**

* 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에(Where) 위치시킬 것인지를 결정하는 전략

▶ **최**초 적합(First Fit): 빈 영역 중에서 첫 번째 분할 영역에 배치

▶ 최**적** 적합(Best Fit): 빈 영역 중에서 단편화를 가정 작게 남기는 분할 영역에 배치\[2022.1회차]

▶ 최**악** 적합(Worst Fit): 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치

\#**최적악**

### 🍇 메모리 할당(**주기억장치 할당의 개념**) **: 메모리 적재 방법 결정**

> 🔗 출처 : https://applejam34.tistory.com/4

![](https://velog.velcdn.com/images/prettylee620/post/87d850a5-2140-4f83-a94f-3362ca4b2271/image.png)

> 메모리에 프로그램을 할당할 때는 **시작 메모리 위치, 메모리의 할당 크기를 기반**으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다.

* 프로그램이나 데이터를 실행시키기 위해 주기억장치에 `어떻게(How) 할당`할지 정함

#### **연**속 할당 기법 -단일 프로그램

* 프로그램을 주기억장치에 연속으로 할당하는 기법
* **단**일 분할 할당 기법
  * 주기억장치를 운영체제랑 사용자로 나누어(경계 레지스터로 구분) 오직 한명의 사용자만이 주기억장치의 사용자 영역을 사용
  * 오버레이, 스와핑

#### 연속 할당 기법 - **다**중 분할 할당 기법

1. `정(정적) 분할 할당 기법`

* 주기억장치의 사용자영역을 크기가 동일한 페이지로 나눠 처리하는 방법

2. `가변(동적) 분할 할당 기법`

* 고장분할할당의 단편화를 줄이기 위한것으로, 주기억장치의 사용영역을 필요한 만큼의 크기로 분할
* 단편화의 상당부분해결하나, 영역과 영역사이에 단편화가 발생

3. **분산** 할당 기법

* 프로그램을 특정 단위의 조각으로 나누어 할당하는 기법

## **3. 페**이징(Paging) 기법 / **세**그먼테이션(Segmentation) 기법

\#**연단다 분페세**

#### 불연속메모리 할당

1. **페이징(Paging) 기법 -** 고정분할

* 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 \*\*`동일한** 크기로 나눈 후 나눠진` 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
* **일정한 크기**로 나눈 단위를 페이지(Page)라 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라 함
* 외부 단편화는 발생하지 않으나, **내부 단편화** **발생 \_\_ 4-48**
* 주소 변환을 위해 페이지의 위치 정보를 갖고 있는 페이지 맵 테이블(Page Map Table) 필요 → 페이지 맵 테이블 사용으로 비용 증가, 처리 속도 감소

**단편화**

| 용어                               | 설명                                                              |
| -------------------------------- | --------------------------------------------------------------- |
| 메모리 단편화                          | 분할된 주기억장치에 프로세스를 할당, 반납 과정에서 사용되지 못하고 낭비되는 기억장치가 발생하는 현상        |
| 내부 단편화                           | 분할된 공간에서 프로세스를 적재한 후 남은 공간으로, 고정 분할 할당 방식 또는 페이징 기법 사용시 발생하는 현상 |
| 2. **세그먼테이션(Segmentation) 기법 ★** |                                                                 |

* 가상기억장치에 보관되어 있는 프로그램을 \*\*`다양한** 크기의 논리적인 단위로 나눈 후` 주기억장치에 적재시켜 기억공간을 절약하기 위해서 사용하는 실행시키는 방법
* 메모리 분산 할당 기법 중 가상기억장치 내의 **프로세스를 서로 크기가 다른 논리적 단위로 분할하고 메모리를 할당하는 기법**으로, 분할 형태가 배열이나 함수와 같은 논리적인 다양한 크기의 가변적인 크기로 관리되는 기법
* 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐
* 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법
* 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 갖고 있는 세그먼트 맵 테이블(Segment Map Table) 필요
* 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요
* 내부 단편화는 발생하지 않으나, **외부 단편화 발생 \_\_ 4-48**

### 🍇 **교체(Replacement) 전략 : 메모리 교체 대상 결정**

> 이미 사용되고 있는 영역 중에서 어느(Who) 영역을 교체할지 결정하는 전략, 가용 공간이 없는 경우

\#FIFO, LRU, LFU, NUR, OPT, SCR

#### **페이지 교체 알고리즘**

▶ **FIFO**(First In First Out) = **FCFS**(First Come First Serve)

* 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 **가장 오래 있었던 페이지를 교체**하는 기법

> 🔗 참고 : [https://velog.io/@infoqoch/운영체제-논리-메모리와-페이지폴트](https://velog.io/@infoqoch/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%85%BC%EB%A6%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8)

![](https://velog.velcdn.com/images/prettylee620/post/babd8f0a-86c3-4792-ae36-e6d3942e81ce/image.png)

▶ **LRU**(Least Recently Used)

* **최근에 가장 오랫동안 사용하지 않은 페이지를 교체**하는 기법
* 가장 오래 전에 사용된 페이지 교체

![](https://velog.velcdn.com/images/prettylee620/post/cbb83414-acf1-46b4-ae41-1c05f1092490/image.png)

▶ **LFU**(Least **Frequently** Used)

* **사용 빈도가 가장 적은 페이지를 교체**하는 기법, 참조횟수가 가장 적은 것을 교체

▶ **OPT**(OPTimal replacement, 최적 교체)

* **앞으로 가장 오랫동안 사용하지 않을 페이지를 교체**하는 기법
* 벨레이디(Belady)가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

![](https://velog.velcdn.com/images/prettylee620/post/02ec3bcf-30f1-4c69-b839-31285cf39130/image.png)

▶ **NUR**(Not Used **Recently**)

* LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
* 각 페이지마다 두 개의 비트, 즉 참조 비트와 변형 비트 사용

| 참조 비트 | 0 | 0 | 1 | 1 |
| ----- | - | - | - | - |
| 변형 비트 | 0 | 1 | 0 | 1 |
| 교체 순서 | 1 | 2 | 3 | 4 |

▶ **SCR**(Second Chance Replacement, 2차 기회 교체)

* 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법

#### **페이지 크기**

▶ **페이지 크기가 작을 경우**

* 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
* 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋 유지 가능
* Locality에 더 일치할 수 있기 때문에 기억장치 효율 높아짐
* 페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 커지고, 매핑 속도가 늦어짐
* 디스크 접근 횟수가 많아져서 전체적인 입, 출력 시간은 늘어남

▶ **페이지 크기가 클 경우**

* 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
* 불필요한 내용까지도 주기억장치에 적재될 수 있음
* 페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 작아지고, 매핑 속도가 빨라짐
* 디스크 접근 횟수가 줄어들어 전체적인 입, 출력 효율성이 증가됨

### 🍇 스레싱

> 🔗 출처 : [https://blog.skby.net/스레싱-thrashing/](https://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)

#### 개념

> Page Fault가 연속적으로 발생하여 프로세스 수행시간보다 **페이지 교체 시간이 많은 상태**

1. 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 **스와핑이 많이 일어나서** 발생
2. **페이지 폴트**가 일어나면 CPU 이용률이 낮아진다.
3. CPU 이용률이 낮아지면 운영체제는 CPU가 한가한 줄 알고 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올리게 되며 스레싱 발생

![](https://velog.velcdn.com/images/prettylee620/post/3dc4da71-0da8-4317-ab92-5db4433f525a/image.png)

#### 주요 원인

* 부적절한 페이지 교체 정책
* 시스템 리소스 부족
* 프로그램 메모리 관리 실

#### **스레싱 예방을 위한 지역성 활용 워킹 셋(Working Set)**

![](https://velog.velcdn.com/images/prettylee620/post/f491fc57-6e5e-4881-8ab7-28fd5a57dfcf/image.png)

* 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
* 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 **줄어들어** 프로세스의 기억장치 사용이 `안정`됨
* 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨

#### **스레싱 예방을 위한 직접 액세스 방식 페이지 부재 빈도(PFF; Page Fault Frequency) 방식**

![](https://velog.velcdn.com/images/prettylee620/post/559d0c15-c745-417f-90f3-1f995cb9d6b4/image.png)

* 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식
* 페이지 부재(Page Fault)는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도는 페이지 부재가 일어나는 횟수를 의미함
* 페이지 부재율의 상한과 하한을 정해 직접적으로 페이지 부재율을 예측하고 조절하는 기법

#### **프리페이징(Prepaging)**

* 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 미리 한꺼번에 페이지 프레임에 적재하는 기법

→ 기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 있음

#### **스래싱 현상 방지 방법**

* 다중 프로그래밍의 정도를 적정 수준으로 유지 **★**
* 페이지 부재 빈도(Page Fault Frequency)를 조절해 사용
* 워킹 세트(Working Set)을 유지함
* 부족한 자원을 증설하고, 일부 프로세스를 중단시킴
* 각 프로세스가 필요로 하는 프레임 제공\[2021.5]
